diff --git a/src/stream.c b/src/stream.c
index f422e16..b0b3b8f 100644
--- a/src/stream.c
+++ b/src/stream.c
@@ -78,6 +78,7 @@
 #define _POSIX_C_SOURCE 199506
 #include <ctype.h>
 #include "rtklib.h"
+#include <signal.h>
 #ifndef WIN32
 #include <fcntl.h>
 #include <unistd.h>
@@ -105,10 +106,11 @@
 #define MAXSTATMSG          32          /* max length of status message */
 #define DEFAULT_MEMBUF_SIZE 4096        /* default memory buffer size (bytes) */
 
-#define NTRIP_AGENT         "RTKLIB/" VER_RTKLIB "_" PATCH_LEVEL
+#define NTRIP_AGENT         "STR2STR"
 #define NTRIP_CLI_PORT      2101        /* default ntrip-client connection port */
 #define NTRIP_SVR_PORT      80          /* default ntrip-server connection port */
 #define NTRIP_MAXRSP        32768       /* max size of ntrip response */
+#define NTRIP_MINRSP        14          /* min size of ntrip response */
 #define NTRIP_MAXSTR        256         /* max length of mountpoint string */
 #define NTRIP_RSP_OK_CLI    "ICY 200 OK\r\n" /* ntrip response: client */
 #define NTRIP_RSP_OK_SVR    "OK\r\n"    /* ntrip response: server */
@@ -116,15 +118,22 @@
 #define NTRIP_RSP_TBLEND    "ENDSOURCETABLE"
 #define NTRIP_RSP_HTTP      "HTTP/"     /* ntrip response: http */
 #define NTRIP_RSP_ERROR     "ERROR"     /* ntrip response: error */
+#define NTRIP_RSP_NOT_FOUND "Not Found" /* ntrip v2 response: not found */
+#define NTRIP_RSP_V2UNAUTH  "Unauthorized" /* ntrip v2 response: unauthorized */
 #define NTRIP_RSP_UNAUTH    "HTTP/1.0 401 Unauthorized\r\n"
 #define NTRIP_RSP_ERR_PWD   "ERROR - Bad Password\r\n"
 #define NTRIP_RSP_ERR_MNTP  "ERROR - Bad Mountpoint\r\n"
+#define MIN_PAUSE_AT_EMPTY  15000       /* min pause for EMPTY response */
+#define MIN_PAUSE_AT_UNAUTH 30000      /* min pause for UNAUTHORIZED response */
 
 #define FTP_CMD             "wget"      /* ftp/http command */
 #define FTP_TIMEOUT         30          /* ftp/http timeout (s) */
 
 #define MIN(x,y)            ((x)<(y)?(x):(y))
 
+#define MAX_PROGRESSIVE_TIMEOUT 300000 /* 5 minute = 300 000 ms */
+#define DROP_PROGRESSIVE_TIME   30000  /* 30 sec   = 30 000 ms */
+#define MAX_NTRIP_CONNECT_TIME   5000  /* 5 sec    = 5 000 ms */
 /* macros --------------------------------------------------------------------*/
 
 #ifdef WIN32
@@ -165,6 +174,8 @@ typedef struct {            /* file control type */
 
 typedef struct {            /* tcp control type */
     int state;              /* state (0:close,1:wait,2:connect) */
+    int connect_state;      /* connect state (0:before connect,1:pause,2:pause ended,3:connect in progress,4:connected) */
+    int use_flag;           /* use flag (0:localhost,1:tcp,2:ntrip) */
     char saddr[256];        /* address string */
     int port;               /* port */
     struct sockaddr_in addr; /* address resolved */
@@ -195,6 +206,8 @@ typedef struct {            /* serial control type */
     rtklib_lock_t lock;     /* lock flag */
     uint8_t *buff;          /* write buffer */
 #endif
+    uint32_t tact;          /* data active tick */
+    int toinact;            /* inactive timeout (ms) (0:no timeout) */
     tcpsvr_t *tcpsvr;       /* tcp server for received stream */
 } serial_t;
 
@@ -266,6 +279,8 @@ typedef struct {            /* memory buffer type */
 static tcpsvr_t *opentcpsvr(const char *path, char *msg);
 static void closetcpsvr(tcpsvr_t *tcpsvr);
 static int writetcpsvr(tcpsvr_t *tcpsvr, uint8_t *buff, int n, char *msg);
+extern void abortfunc(const char *msg);
+__attribute__((weak)) void abortfunc(const char *msg) {raise(SIGABRT);(void)msg;}
 
 /* global options ------------------------------------------------------------*/
 
@@ -277,6 +292,8 @@ static char localdir[1024]=""; /* local directory for ftp/http */
 static char proxyaddr[256]=""; /* http/ntrip/ftp proxy address */
 static uint32_t tick_master=0; /* time tick master for replay */
 static int fswapmargin=30;  /* file swap margin (s) */
+static int was_1st_ntrip_connect = 0;
+static char revisionstr[64]="ELT_RTKBase"; /* revision string */
 
 /* read/write serial buffer --------------------------------------------------*/
 #ifdef WIN32
@@ -455,7 +472,7 @@ static serial_t *openserial(const char *path, int mode, char *msg)
         free(serial);
         return NULL;
     }
-    sprintf(msg,"%s",port);
+    sprintf(msg,"open %s",port);
 #else
     sprintf(dev,"/dev/%.*s",(int)sizeof(port)-6,port);
     
@@ -483,7 +500,7 @@ static serial_t *openserial(const char *path, int mode, char *msg)
     ios.c_cflag|=!strcmp(fctr,"rts")?CRTSCTS:0;
     tcsetattr(serial->dev,TCSANOW,&ios);
     tcflush(serial->dev,TCIOFLUSH);
-    sprintf(msg,"%s",dev);
+    sprintf(msg,"open %s",dev);
 #endif
     serial->tcpsvr=NULL;
     
@@ -493,6 +510,8 @@ static serial_t *openserial(const char *path, int mode, char *msg)
         serial->tcpsvr=opentcpsvr(path_tcp,msg_tcp);
     }
     tracet(3,"openserial: dev=%d\n",serial->dev);
+    serial->toinact=toinact;
+    serial->tact=tickget();
     return serial;
 }
 /* close serial --------------------------------------------------------------*/
@@ -537,6 +556,14 @@ static int readserial(serial_t *serial, uint8_t *buff, int n, char *msg)
         /* TODO handle no-blocking write ? */
         writetcpsvr(serial->tcpsvr,buff,(int)nr,msg_tcp);
     }
+    if (nr>0)
+       serial->tact=tickget();
+    else if (serial->toinact>0&&
+         (int)(tickget()-serial->tact)>serial->toinact) {
+       sprintf(msg,"serial inactive timeout %.1f sec",serial->toinact/1000.0);
+       tracet(2,"readserial: inactive timeout dev=%d\n",serial->dev);
+       abortfunc(msg);
+    }
     return nr;
 }
 /* write serial --------------------------------------------------------------*/
@@ -1065,7 +1092,7 @@ static socket_t accept_nb(socket_t sock, struct sockaddr *addr, socklen_t *len,
 static int connect_nb(socket_t sock, struct sockaddr *addr, socklen_t len, int *err)
 {
 #ifdef WIN32
-    u_long mode=1; 
+    u_long mode=1;
     ioctlsocket(sock,FIONBIO,&mode);
     if (connect(sock,addr,len)==-1) {
         *err=errsock();
@@ -1076,16 +1103,26 @@ static int connect_nb(socket_t sock, struct sockaddr *addr, socklen_t len, int *
 #else
     int flag = fcntl(sock, F_GETFL, 0);
     fcntl(sock, F_SETFL, flag | O_NONBLOCK);
+    errno=0;
     if (connect(sock, addr, len) == -1) {
         *err = errsock();
+        tracet(3,"connect_nb: connect sock=%d err=%d\n",sock,*err);
         if (*err != EISCONN && *err != EINPROGRESS && *err != EALREADY) return -1;
         fd_set rs, ws;
         FD_ZERO(&rs); FD_SET(sock, &rs); ws = rs;
         struct timeval tv = {0};
-        if (select(sock + 1, &rs, &ws, NULL, &tv) == 0) {
+        int res = select(sock + 1, &rs, &ws, NULL, &tv);
+        if (res == 0) {
           *err = 0;
           return 0;
         }
+        tracet(3,"connect_nb: select sock=%d res=%d rs=%d ws=%d\n",sock,res,FD_ISSET(sock,&rs),FD_ISSET(sock,&ws));
+        if (FD_ISSET(sock,&ws)) {
+           res=send(sock,(char *)&flag,0,0);
+           *err=errsock();
+           tracet(3,"connect_nb: send sock=%d res=%d err=%d ws=%d\n",sock,res,*err);
+           if (res==-1) return -1;
+        }
         *err = 0;
         return 1;
     }
@@ -1143,20 +1180,124 @@ static int send_nb(socket_t sock, uint8_t *buff, int n, int *err)
     *err = 0;
     return ns;
 }
+/* get error text ------------------------------------------------------------*/
+static char errbuf[200];
+static char *errorstring(int err)
+{
+    strncpy(errbuf,strerror(err),sizeof(errbuf));
+    errbuf[sizeof(errbuf)-1] = 0;
+    int Len = (int)strlen(errbuf)-1;
+    while ((Len >= 0) && (errbuf[Len] < ' ')) --Len;
+    errbuf[Len+1] = 0;
+    return errbuf;
+}
+/* setup error flag ----------------------------------------------------------*/
+static char flagpath[MAXSTRPATH] = "";  /* flag file file path */
+extern void flagsetup(const char *path)
+{
+   strncpy(flagpath,path,MAXSTRPATH);
+   flagpath[MAXSTRPATH-1]=0;
+}
+/* create error flag ---------------------------------------------------------*/
+static void flagcreate(const char *msg)
+{
+    if (!*flagpath) return;
+    FILE *file=fopen(flagpath,"wt");
+    if (file) {
+        fputs(msg,file);
+        fclose(file);
+    }
+}
+/* erase error flag ----------------------------------------------------------*/
+static void flagerase(void)
+{
+    if (!*flagpath) return;
+    remove(flagpath);
+}
+/* setup event command--------------------------------------------------------*/
+static char eventpath[MAXSTRPATH] = "";  /* flag file file path */
+extern void eventsetup(const char *path)
+{
+   strncpy(eventpath,path,MAXSTRPATH);
+   eventpath[MAXSTRPATH-1]=0;
+}
+/* setup revision string --------------------------------------------------------*/
+extern void revisionsetup(const char *str)
+{
+   strcpy(revisionstr,str);
+}
+/* execute event command ---------------------------------------------------------*/
+static void eventexec(const char *msg)
+{
+   if (!*eventpath) return;
+   char systempath[MAXSTRPATH];
+   strcpy(systempath,eventpath);
+   size_t len=strlen(systempath);
+   char *p=systempath+len;
+   *p++=' ';
+   size_t msglen=strlen(msg)+1;
+   if (msglen > (MAXSTRPATH-(len+1)))
+      msglen = MAXSTRPATH-(len+1);
+   if (msglen > 0)
+      strncpy(p,msg,msglen);
+   *(p+msglen-1)=0;
+   tracet(3,"eventexec: %s\n",systempath);
+   //fprintf(stderr,"systempath=%s\n",systempath);
+   system(systempath);
+}
+/* disconnect tcp ------------------------------------------------------------*/
+static void discontcp(tcp_t *tcp, int tcon, const char *msg)
+{
+    tracet(3,"discontcp: sock=%d tcon=%d\n",tcp->sock,tcon);
+    if (tcp->use_flag) {
+       flagcreate(msg);
+       eventexec("DISCONNECT");
+    }
+
+    closesocket(tcp->sock);
+    tcp->state=0;
+    tcp->connect_state=0;
+    if (tcp->tcon) {
+        tcp->tcon *= 2;
+        if (tcp->tcon>MAX_PROGRESSIVE_TIMEOUT)
+            tcp->tcon=MAX_PROGRESSIVE_TIMEOUT;
+    } else
+       tcp->tcon=tcon;
+    tcp->tdis=tickget();
+}
 /* generate tcp socket -------------------------------------------------------*/
 static int gentcp(tcp_t *tcp, int type, char *msg)
 {
     struct hostent *hp;
+    int newstate;
 #ifdef SVR_REUSEADDR
     int opt=1;
 #endif
+    int err;
     
-    tracet(3,"gentcp: type=%d\n",type);
+    tracet(4,"gentcp: type=%d\n",type);
     
+    /* wait re-connect */
+    if (tcp->connect_state < 2) {
+       if ((tcp->tcon>0) && ((int)(tickget()-tcp->tdis)<tcp->tcon)) {
+           if (!tcp->connect_state && !*msg) {
+              sprintf(msg,"tcp connect pause %d sec",tcp->tcon/1000);
+              tcp->connect_state = 1;
+              eventexec("PAUSE");
+           }
+           return 0;
+       } else {
+          tcp->connect_state = 2;
+          if (tcp->use_flag)
+             eventexec("CONNECTING");
+       }
+    }
+
     /* generate socket */
     if ((tcp->sock=socket(AF_INET,SOCK_STREAM,0))==(socket_t)-1) {
-        sprintf(msg,"socket error (%d)",errsock());
-        tracet(1,"gentcp: socket error err=%d\n",errsock());
+        int err=errsock();
+        sprintf(msg,"socket error %d (%s)",err,errorstring(err));
+        tracet(1,"gentcp: socket error err=%d\n",err);
         tcp->state=-1;
         return 0;
     }
@@ -1167,17 +1308,26 @@ static int gentcp(tcp_t *tcp, int type, char *msg)
     memset(&tcp->addr,0,sizeof(tcp->addr));
     tcp->addr.sin_family=AF_INET;
     tcp->addr.sin_port=htons(tcp->port);
-    
+
     if (type==0) { /* server socket */
-    
+
 #ifdef SVR_REUSEADDR
         /* multiple-use of server socket */
         setsockopt(tcp->sock,SOL_SOCKET,SO_REUSEADDR,(const char *)&opt,
                    sizeof(opt));
 #endif
+        if (!(hp=gethostbyname(tcp->saddr))) {
+            if ((err=errsock())) {
+               sprintf(msg,"server address error %d (%s) at %s",err,errorstring(err),tcp->saddr);
+               tracet(1,"gentcp: gethostbyname error addr=%s err=%d\n",tcp->saddr,err);
+            }
+        } else
+            memcpy(&tcp->addr.sin_addr,hp->h_addr,hp->h_length);
+
         if (bind(tcp->sock,(struct sockaddr *)&tcp->addr,sizeof(tcp->addr))==-1) {
-            sprintf(msg,"bind error (%d) : %d",errsock(),tcp->port);
-            tracet(1,"gentcp: bind error port=%d err=%d\n",tcp->port,errsock());
+            err=errsock();
+            sprintf(msg,"bind error %d (%s) at %d",err,errorstring(err),tcp->port);
+            tracet(1,"gentcp: bind error port=%d err=%d\n",tcp->port,err);
             closesocket(tcp->sock);
             tcp->state=-1;
             return 0;
@@ -1186,13 +1336,17 @@ static int gentcp(tcp_t *tcp, int type, char *msg)
     }
     else { /* client socket */
         if (!(hp=gethostbyname(tcp->saddr))) {
-            sprintf(msg,"address error (%s)",tcp->saddr);
-            // h_errno ?
-            tracet(1,"gentcp: gethostbyname error addr=%s err=%d\n",tcp->saddr,errsock());
-            closesocket(tcp->sock);
-            tcp->state=0;
-            tcp->tcon=ticonnect;
-            tcp->tdis=tickget();
+            err=h_errno;
+            if (!*(tcp->saddr)) {
+               sprintf(msg,"client address EMPTY");
+               newstate=-1;
+            } else {
+               sprintf(msg,"client address error <%s> at <%s>",hstrerror(err),tcp->saddr);
+               newstate = (err == TRY_AGAIN) ? 0 : -1;
+            }
+            tracet(1,"gentcp: gethostbyname error addr=%s herr=%d\n",tcp->saddr,err);
+            discontcp(tcp, ticonnect, msg);
+            tcp->state=newstate;
             return 0;
         }
         memcpy(&tcp->addr.sin_addr,hp->h_addr,hp->h_length);
@@ -1202,16 +1356,6 @@ static int gentcp(tcp_t *tcp, int type, char *msg)
     tracet(5,"gentcp: exit sock=%d\n",tcp->sock);
     return 1;
 }
-/* disconnect tcp ------------------------------------------------------------*/
-static void discontcp(tcp_t *tcp, int tcon)
-{
-    tracet(3,"discontcp: sock=%d tcon=%d\n",tcp->sock,tcon);
-    
-    closesocket(tcp->sock);
-    tcp->state=0;
-    tcp->tcon=tcon;
-    tcp->tdis=tickget();
-}
 /* open tcp server -----------------------------------------------------------*/
 static tcpsvr_t *opentcpsvr(const char *path, char *msg)
 {
@@ -1266,11 +1410,11 @@ static void updatetcpsvr(tcpsvr_t *tcpsvr, char *msg)
     }
     if (n==0) {
         tcpsvr->svr.state=1;
-        sprintf(msg,"waiting...");
+        /*sprintf(msg,"waiting...");*/
         return;
     }
     tcpsvr->svr.state=2;
-    if (n==1) sprintf(msg,"%s",saddr); else sprintf(msg,"%d clients",n);
+    /*if (n==1) sprintf(msg,"client %s",saddr); else sprintf(msg,"%d clients",n);*/
 }
 /* accept client connection --------------------------------------------------*/
 static int accsock(tcpsvr_t *tcpsvr, char *msg)
@@ -1279,9 +1423,9 @@ static int accsock(tcpsvr_t *tcpsvr, char *msg)
     socket_t sock;
     socklen_t len=sizeof(addr);
     int i,err;
-    
+
     tracet(4,"accsock: sock=%d\n",tcpsvr->svr.sock);
-    
+
     for (i=0;i<MAXCLI;i++) {
         if (tcpsvr->cli[i].state==0) break;
     }
@@ -1290,7 +1434,7 @@ static int accsock(tcpsvr_t *tcpsvr, char *msg)
         return 0;
     }
     if ((sock=accept_nb(tcpsvr->svr.sock,(struct sockaddr *)&addr,&len,&err))==(socket_t)-1) {
-        sprintf(msg,"accept error (%d)",err);
+        sprintf(msg,"accept error %d (%s)",err,errorstring(err));
         tracet(1,"accsock: accept error sock=%d err=%d\n",tcpsvr->svr.sock,err);
         closesocket(tcpsvr->svr.sock);
         tcpsvr->svr.state=0;
@@ -1302,11 +1446,12 @@ static int accsock(tcpsvr_t *tcpsvr, char *msg)
     tcpsvr->cli[i].sock=sock;
     memcpy(&tcpsvr->cli[i].addr,&addr,sizeof(addr));
     strcpy(tcpsvr->cli[i].saddr,inet_ntoa(addr.sin_addr));
-    sprintf(msg,"%s",tcpsvr->cli[i].saddr);
+    sprintf(msg,"accept client %s",tcpsvr->cli[i].saddr);
     tracet(3,"accsock: connected sock=%d addr=%s i=%d\n",
            tcpsvr->cli[i].sock,tcpsvr->cli[i].saddr,i);
     tcpsvr->cli[i].state=2;
     tcpsvr->cli[i].tact=tickget();
+    tcpsvr->cli[i].tcon=0;
     return 1;
 }
 /* wait socket accept --------------------------------------------------------*/
@@ -1338,8 +1483,15 @@ static int readtcpsvr(tcpsvr_t *tcpsvr, uint8_t *buff, int n, char *msg)
                 tracet(2,"readtcpsvr: recv error sock=%d err=%d\n",
                        tcpsvr->cli[i].sock,err);
             }
-            discontcp(&tcpsvr->cli[i],ticonnect);
-            updatetcpsvr(tcpsvr,msg);
+            if ((err!=EALREADY) && (err!=EINPROGRESS)) {
+                if (err==0)
+                    sprintf(msg,"tcp server recv disconnected by %s",tcpsvr->cli[i].saddr);
+                else
+                    sprintf(msg,"tcp server recv error %d (%s) at %s",
+                            err,errorstring(err),tcpsvr->cli[i].saddr);
+                discontcp(&tcpsvr->cli[i],ticonnect,msg);
+                updatetcpsvr(tcpsvr,msg);
+            }
         }
         if (nr>0) {
             tcpsvr->cli[i].tact=tickget();
@@ -1362,10 +1514,15 @@ static int writetcpsvr(tcpsvr_t *tcpsvr, uint8_t *buff, int n, char *msg)
         
         if ((ns=send_nb(tcpsvr->cli[i].sock,buff,n,&err))==-1) {
             if (err) {
-                tracet(2,"writetcpsvr: send error i=%d sock=%d err=%d\n",i,
-                       tcpsvr->cli[i].sock,err);
-            }
-            discontcp(&tcpsvr->cli[i],ticonnect);
+               tracet(2,"writetcpsvr: send error i=%d sock=%d err=%d\n",i,
+                      tcpsvr->cli[i].sock,err);
+               if ((err==EPIPE) && !recv(tcpsvr->cli[i].sock,(char *)buff,1,0))
+                  sprintf(msg,"tcp server send disconnected by %s",tcpsvr->cli[i].saddr);
+               else
+                   sprintf(msg,"tcp server send error %d (%s) at %s",err,errorstring(err),tcpsvr->cli[i].saddr);
+            } else
+                sprintf(msg,"tcp server send not all, disconnected by %s",tcpsvr->cli[i].saddr);
+            discontcp(&tcpsvr->cli[i],ticonnect,msg);
             updatetcpsvr(tcpsvr,msg);
         }
         else {
@@ -1420,29 +1577,39 @@ static int consock(tcpcli_t *tcpcli, char *msg)
     int stat,err;
     
     tracet(4,"consock: sock=%d\n",tcpcli->svr.sock);
-    
-    /* wait re-connect */
-    if (tcpcli->svr.tcon<0||(tcpcli->svr.tcon>0&&
-        (int)(tickget()-tcpcli->svr.tdis)<tcpcli->svr.tcon)) {
-        return 0;
-    }
+
     /* non-block connect */
     if ((stat=connect_nb(tcpcli->svr.sock,(struct sockaddr *)&tcpcli->svr.addr,
                          sizeof(tcpcli->svr.addr),&err))==-1) {
-        sprintf(msg,"connect error (%d)",err);
+        sprintf(msg,"tcp connect error %d (%s) at %s:%d",err,errorstring(err),tcpcli->svr.saddr,tcpcli->svr.port);
         tracet(2,"consock: connect error sock=%d err=%d\n",tcpcli->svr.sock,err);
-        closesocket(tcpcli->svr.sock);
-        tcpcli->svr.state=0;
+        discontcp(&tcpcli->svr,tcpcli->tirecon,msg);
         return 0;
     }
     if (!stat) { /* not connect */
-        sprintf(msg,"connecting...");
+        if ((tcpcli->svr.connect_state < 3) && !*msg) {
+           if (!tcpcli->svr.connect_state && (tcpcli->svr.tcon>0))
+               sprintf(msg,"tcp connecting after pause %d sec to %s:%d in progress",
+                       tcpcli->svr.tcon/1000,tcpcli->svr.saddr,tcpcli->svr.port);
+           else
+               sprintf(msg,"tcp connecting to %s:%d in progress",tcpcli->svr.saddr,tcpcli->svr.port);
+           tcpcli->svr.connect_state=3;
+        }
         return 0;
     }
-    sprintf(msg,"%s",tcpcli->svr.saddr);
-    tracet(3,"consock: connected sock=%d addr=%s\n",tcpcli->svr.sock,tcpcli->svr.saddr);
+    if (!tcpcli->svr.connect_state && (tcpcli->svr.tcon>0))
+       sprintf(msg,"tcp connect after pause %d sec to %s:%d",tcpcli->svr.tcon/1000,tcpcli->svr.saddr,tcpcli->svr.port);
+    else
+       sprintf(msg,"tcp connect %s:%d",tcpcli->svr.saddr,tcpcli->svr.port);
+    tracet(3,"consock: connected sock=%d addr=%s:%d\n",tcpcli->svr.sock,tcpcli->svr.saddr,tcpcli->svr.port);
     tcpcli->svr.state=2;
+    tcpcli->svr.connect_state=4;
     tcpcli->svr.tact=tickget();
+    tcpcli->svr.tdis=tcpcli->svr.tact;
+    if (tcpcli->svr.use_flag == 1) {
+       flagerase();
+       eventexec("CONNECTED");
+    }
     return 1;
 }
 /* open tcp client -----------------------------------------------------------*/
@@ -1457,7 +1624,7 @@ static tcpcli_t *opentcpcli(const char *path, char *msg)
     *tcpcli=tcpcli0;
     decodetcppath(path,tcpcli->svr.saddr,port,NULL,NULL,NULL,NULL);
     if (sscanf(port,"%d",&tcpcli->svr.port)<1) {
-        sprintf(msg,"port error: %s",port);
+        sprintf(msg,"tcp client port error: %s",port);
         tracet(2,"opentcp: port error port=%s\n",port);
         free(tcpcli);
         return NULL;
@@ -1465,6 +1632,7 @@ static tcpcli_t *opentcpcli(const char *path, char *msg)
     tcpcli->svr.tcon=0;
     tcpcli->toinact=toinact;
     tcpcli->tirecon=ticonnect;
+    tcpcli->svr.use_flag=strcmp(tcpcli->svr.saddr,"localhost") ? 1 : 0;
     return tcpcli;
 }
 /* close tcp client ----------------------------------------------------------*/
@@ -1479,9 +1647,13 @@ static void closetcpcli(tcpcli_t *tcpcli)
 static int waittcpcli(tcpcli_t *tcpcli, char *msg)
 {
     tracet(4,"waittcpcli: sock=%d state=%d\n",tcpcli->svr.sock,tcpcli->svr.state);
-    
-    if (tcpcli->svr.state<0) return 0;
-    
+
+    if (tcpcli->svr.state<0) {
+       sprintf(msg,"tcp client state abnormal(%d), exiting", tcpcli->svr.state);
+       abortfunc(msg);
+       return 0;
+    }
+
     if (tcpcli->svr.state==0) { /* close */
         if (!gentcp(&tcpcli->svr,1,msg)) return 0;
     }
@@ -1491,9 +1663,16 @@ static int waittcpcli(tcpcli_t *tcpcli, char *msg)
     if (tcpcli->svr.state==2) { /* connect */
         if (tcpcli->toinact>0&&
             (int)(tickget()-tcpcli->svr.tact)>tcpcli->toinact) {
-            sprintf(msg,"timeout");
+            sprintf(msg,"tcp client inactive timeout %s",tcpcli->svr.saddr);
             tracet(2,"waittcpcli: inactive timeout sock=%d\n",tcpcli->svr.sock);
-            discontcp(&tcpcli->svr,tcpcli->tirecon);
+            discontcp(&tcpcli->svr,tcpcli->tirecon,msg);
+            return 0;
+        }
+        if (tcpcli->svr.tcon&&
+            (int)(tickget()-tcpcli->svr.tdis)>=DROP_PROGRESSIVE_TIME) {
+            //sprintf(msg,"tcp client clean progressive timeout %s",tcpcli->svr.saddr);
+            tracet(2,"waittcpcli: clean progressive timeout sock=%d\n",tcpcli->svr.sock);
+            tcpcli->svr.tcon=0;
             return 0;
         }
     }
@@ -1511,12 +1690,14 @@ static int readtcpcli(tcpcli_t *tcpcli, uint8_t *buff, int n, char *msg)
     if ((nr=recv_nb(tcpcli->svr.sock,buff,n,&err))==-1) {
         if (err) {
             tracet(2,"readtcpcli: recv error sock=%d err=%d\n",tcpcli->svr.sock,err);
-            sprintf(msg,"recv error (%d)",err);
         }
-        else {
-            sprintf(msg,"disconnected");
+        if ((err!=EALREADY) && (err!=EINPROGRESS)) {
+           if (err==0)
+               sprintf(msg,"tcp client recv disconnected by %s",tcpcli->svr.saddr);
+           else
+               sprintf(msg,"tcp client recv error %d (%s) at %s",err,errorstring(err),tcpcli->svr.saddr);
+           discontcp(&tcpcli->svr,tcpcli->tirecon,msg);
         }
-        discontcp(&tcpcli->svr,tcpcli->tirecon);
         return 0;
     }
     if (nr>0) tcpcli->svr.tact=tickget();
@@ -1535,9 +1716,13 @@ static int writetcpcli(tcpcli_t *tcpcli, uint8_t *buff, int n, char *msg)
     if ((ns=send_nb(tcpcli->svr.sock,buff,n,&err))==-1) {
         if (err) {
             tracet(2,"writetcp: send error sock=%d err=%d\n",tcpcli->svr.sock,err);
-            sprintf(msg,"send error (%d)",err);
-        }
-        discontcp(&tcpcli->svr,tcpcli->tirecon);
+            if ((err==EPIPE) && !recv(tcpcli->svr.sock,(char *)buff,1,0))
+               sprintf(msg,"tcp client send disconnected by %s",tcpcli->svr.saddr);
+            else
+               sprintf(msg,"tcp client send error %d (%s) at %s",err,errorstring(err),tcpcli->svr.saddr);
+        } else
+            sprintf(msg,"tcp client send not all, disconnected by %s",tcpcli->svr.saddr);
+        discontcp(&tcpcli->svr,tcpcli->tirecon,msg);
         return 0;
     }
     if (ns>0) tcpcli->svr.tact=tickget();
@@ -1582,12 +1767,13 @@ static int reqntrip_s(ntrip_t *ntrip, char *msg)
     tracet(3,"reqntrip_s: state=%d\n",ntrip->state);
     
     p+=sprintf(p,"SOURCE %s %s\r\n",ntrip->passwd,ntrip->mntpnt);
-    p+=sprintf(p,"Source-Agent: NTRIP %s\r\n",NTRIP_AGENT);
-    p+=sprintf(p,"STR: %s\r\n",ntrip->str);
+    p+=sprintf(p,"Source-Agent: NTRIP %s/%s\r\n",NTRIP_AGENT,revisionstr);
+    if (*ntrip->str)
+       p+=sprintf(p,"STR: %s\r\n",ntrip->str);
     p+=sprintf(p,"\r\n");
-    
+
     if (writetcpcli(ntrip->tcp,(uint8_t *)buff,p-buff,msg)!=p-buff) return 0;
-    
+
     tracet(3,"reqntrip_s: send request state=%d ns=%d\n",ntrip->state,p-buff);
     tracet(5,"reqntrip_s: n=%d buff=\n%s\n",p-buff,buff);
     ntrip->state=1;
@@ -1601,7 +1787,7 @@ static int reqntrip_c(ntrip_t *ntrip, char *msg)
     tracet(3,"reqntrip_c: state=%d\n",ntrip->state);
     
     p+=sprintf(p,"GET %s/%s HTTP/1.0\r\n",ntrip->url,ntrip->mntpnt);
-    p+=sprintf(p,"User-Agent: NTRIP %s\r\n",NTRIP_AGENT);
+    p+=sprintf(p,"User-Agent: NTRIP %s/%s\r\n",NTRIP_AGENT,revisionstr);
     
     if (!*ntrip->user) {
         p+=sprintf(p,"Accept: */*\r\n");
@@ -1622,6 +1808,15 @@ static int reqntrip_c(ntrip_t *ntrip, char *msg)
     ntrip->state=1;
     return 1;
 }
+/* set reconnect time at hard error ------------------------------------------*/
+void set_reconnect_time_at_hard_error(ntrip_t *ntrip)
+{
+  if (was_1st_ntrip_connect) {
+    if (ntrip->tcp->svr.tcon < MIN_PAUSE_AT_UNAUTH)
+      ntrip->tcp->svr.tcon = MIN_PAUSE_AT_UNAUTH;
+  } else
+    ntrip->tcp->svr.tcon = MAX_PROGRESSIVE_TIMEOUT;
+}
 /* test ntrip server response ------------------------------------------------*/
 static int rspntrip_s(ntrip_t *ntrip, char *msg)
 {
@@ -1636,27 +1831,56 @@ static int rspntrip_s(ntrip_t *ntrip, char *msg)
         /* Discard all buffer content before the OK. */
         memmove(ntrip->buff, p, ntrip->nb);
         ntrip->state=2;
-        sprintf(msg,"%s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
+        sprintf(msg,"ntrip server connected to %s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
         tracet(3,"rspntrip_s: response ok nb=%d\n",ntrip->nb);
+        flagerase();
+        eventexec("CONNECTED");
+        was_1st_ntrip_connect = 1;
         return 1;
     }
     else if (strstr((char *)ntrip->buff,NTRIP_RSP_ERROR)) { /* error */
         int nb=ntrip->nb<MAXSTATMSG?ntrip->nb:MAXSTATMSG;
-        sprintf(msg,"%.*s",nb,(char *)ntrip->buff);
+        sprintf(msg,"ntrip server error %.*s",nb,(char *)ntrip->buff);
         if ((p=strchr(msg,'\r'))) *p='\0';
         tracet(3,"rspntrip_s: %s nb=%d\n",msg,ntrip->nb);
         ntrip->nb=0;
         ntrip->buff[0]='\0';
         ntrip->state=0;
-        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
+    }
+    else if ((p=strstr((char *)ntrip->buff,NTRIP_RSP_NOT_FOUND))) { /* v2 Not Found */
+        sprintf(msg,"ntrip server mountpoint is INVALID for %s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
+        tracet(3,"rspntrip_s: %s nb=%d\n",msg,ntrip->nb);
+        ntrip->nb=0;
+        ntrip->buff[0]='\0';
+        ntrip->state=0;
+        set_reconnect_time_at_hard_error(ntrip);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
+    }
+    else if ((p=strstr((char *)ntrip->buff,NTRIP_RSP_V2UNAUTH))) { /* v2 Unauthorized */
+        sprintf(msg,"ntrip server password is INVALID for %s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
+        tracet(3,"rspntrip_s: %s nb=%d\n",msg,ntrip->nb);
+        ntrip->nb=0;
+        ntrip->buff[0]='\0';
+        ntrip->state=0;
+        set_reconnect_time_at_hard_error(ntrip);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
     }
     else if (ntrip->nb>=NTRIP_MAXRSP) { /* buffer overflow */
-        sprintf(msg,"response overflow");
+        sprintf(msg,"ntrip server response overflow to %s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
         tracet(3,"rspntrip_s: response overflow nb=%d\n",ntrip->nb);
         ntrip->nb=0;
         ntrip->buff[0]='\0';
         ntrip->state=0;
-        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
+    } else if ((ntrip->nb>=NTRIP_MINRSP) && (p=strchr((char *)ntrip->buff,'\n'))) {
+        *p=0;
+        sprintf(msg,"ntrip server error %s",(char *)ntrip->buff);
+        tracet(3,"rspntrip_s: %s nb=%d\n",msg,ntrip->nb);
+        ntrip->nb=0;
+        ntrip->buff[0]='\0';
+        ntrip->state=0;
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
     }
     tracet(5,"rspntrip_s: exit state=%d nb=%d\n",ntrip->state,ntrip->nb);
     return 0;
@@ -1675,19 +1899,20 @@ static int rspntrip_c(ntrip_t *ntrip, char *msg)
         /* Discard all buffer content before the OK. */
         memmove(ntrip->buff, p, ntrip->nb);
         ntrip->state=2;
-        sprintf(msg,"%s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
+        sprintf(msg,"ntrip client connect to %s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
         tracet(3,"rspntrip_c: response ok nb=%d\n",ntrip->nb);
         ntrip->tcp->tirecon=ticonnect;
+        flagerase();
         return 1;
     }
     if (strstr((char *)ntrip->buff,NTRIP_RSP_SRCTBL)) { /* source table */
         if (!*ntrip->mntpnt) { /* source table request */
             ntrip->state=2;
-            sprintf(msg,"source table received");
+            sprintf(msg,"ntrip client source table received from %s",ntrip->tcp->svr.saddr);
             tracet(3,"rspntrip_c: receive source table nb=%d\n",ntrip->nb);
             return 1;
         }
-        sprintf(msg,"no mountp. reconnect...");
+        sprintf(msg,"ntrip client no mountpoint at %s/%s",ntrip->tcp->svr.saddr,ntrip->mntpnt);
         tracet(2,"rspntrip_c: no mount point nb=%d\n",ntrip->nb);
         ntrip->nb=0;
         ntrip->buff[0]='\0';
@@ -1695,25 +1920,25 @@ static int rspntrip_c(ntrip_t *ntrip, char *msg)
         /* increase subsequent disconnect time to avoid too many reconnect requests */
         if (ntrip->tcp->tirecon>300000) ntrip->tcp->tirecon=ntrip->tcp->tirecon*5/4;
 
-        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
     }
     else if ((p=strstr((char *)ntrip->buff,NTRIP_RSP_HTTP))) { /* http response */
         char *q;
         if ((q=strchr(p,'\r'))) *q='\0'; else ntrip->buff[128]='\0';
-        strcpy(msg,p);
-        tracet(3,"rspntrip_s: %s nb=%d\n",msg,ntrip->nb);
+        sprintf(msg,"ntrip client error %s",p);
+        tracet(3,"rspntrip_c: %s nb=%d\n",msg,ntrip->nb);
         ntrip->nb=0;
         ntrip->buff[0]='\0';
         ntrip->state=0;
-        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
     }
     else if (ntrip->nb>=NTRIP_MAXRSP) { /* buffer overflow */
-        sprintf(msg,"response overflow");
-        tracet(2,"rspntrip_s: response overflow nb=%d\n",ntrip->nb);
+        sprintf(msg,"ntrip client response overflow at %s",ntrip->tcp->svr.saddr);
+        tracet(2,"rspntrip_c: response overflow nb=%d\n",ntrip->nb);
         ntrip->nb=0;
         ntrip->buff[0]='\0';
         ntrip->state=0;
-        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon);
+        discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
     }
     tracet(5,"rspntrip_c: exit state=%d nb=%d\n",ntrip->state,ntrip->nb);
     return 0;
@@ -1726,10 +1951,30 @@ static int waitntrip(ntrip_t *ntrip, char *msg)
     
     tracet(4,"waitntrip: state=%d nb=%d\n",ntrip->state,ntrip->nb);
     
-    if (ntrip->state<0) return 0; /* error */
+    if (ntrip->state<0) { /* error */
+        sprintf(msg,"ntrip state (%d) error",ntrip->state);
+        tracet(2,"waitntrip: ntrip state (%d) error\n",ntrip->state);
+        ntrip->state=0;
+        return 0;
+    }
     
     if (ntrip->tcp->svr.state<2) ntrip->state=0; /* tcp disconnected */
-    
+
+    if ((ntrip->state<2) && !(ntrip->tcp->svr.state<2)) { /* check connect */
+        if ((int)(tickget()-ntrip->tcp->svr.tdis)>=MAX_NTRIP_CONNECT_TIME) {
+            if (ntrip->nb) {
+               ntrip->buff[ntrip->nb]='\0';
+               sprintf(msg,"ntrip connection timeout from %s (server answer: %s)",ntrip->tcp->svr.saddr, ntrip->buff);
+            } else {
+               sprintf(msg,"ntrip connection no answer from %s",ntrip->tcp->svr.saddr);
+            }
+            tracet(2,"waitntrip: ntrip connection answer timeout %s sock=%d\n",ntrip->buff,ntrip->tcp->svr.sock);
+            discontcp(&ntrip->tcp->svr,ntrip->tcp->tirecon,msg);
+            ntrip->state=0;
+            return 0;
+        }
+    }
+
     if (ntrip->state==0) { /* send request */
         if (!(ntrip->type==0?reqntrip_s(ntrip,msg):reqntrip_c(ntrip,msg))) {
             return 0;
@@ -1738,8 +1983,23 @@ static int waitntrip(ntrip_t *ntrip, char *msg)
     }
     if (ntrip->state==1) { /* read response */
         p=(char *)ntrip->buff+ntrip->nb;
-        if ((n=readtcpcli(ntrip->tcp,(uint8_t *)p,NTRIP_MAXRSP-ntrip->nb-1,msg))==0) {
-            tracet(5,"waitntrip: readtcp n=%d\n",n);
+        n=readtcpcli(ntrip->tcp,(uint8_t *)p,NTRIP_MAXRSP-ntrip->nb-1,msg);
+        tracet((ntrip->tcp->svr.state ? 5 : 3),"waitntrip: readtcp n=%d nb=%d tcp_state=%d\n",
+               n, ntrip->nb, ntrip->tcp->svr.state);
+        if (n==0) {
+           if (!ntrip->tcp->svr.state) {
+               if (ntrip->nb) {
+                  sprintf(msg,"NTRIP connection recv disconnected by %s",ntrip->tcp->svr.saddr);
+                  ntrip->type==0?rspntrip_s(ntrip,msg):rspntrip_c(ntrip,msg);
+               } else {
+                  if (ntrip->tcp->svr.tcon < MIN_PAUSE_AT_EMPTY)
+                     ntrip->tcp->svr.tcon = MIN_PAUSE_AT_EMPTY;
+                  sprintf(msg,"NTRIP connection recv disconnected by %s with EMPTY response",ntrip->tcp->svr.saddr);
+               }
+               if (ntrip->tcp->svr.use_flag)
+                  flagcreate(msg);
+               ntrip->state=0;
+            }
             return 0;
         }
         ntrip->nb+=n; ntrip->buff[ntrip->nb]='\0';
@@ -1757,7 +2017,7 @@ static ntrip_t *openntrip(const char *path, int type, char *msg)
     char addr[256]="",port[256]="",tpath[MAXSTRPATH];
     
     tracet(3,"openntrip: path=%s type=%d\n",path,type);
-    
+
     if (!(ntrip=(ntrip_t *)malloc(sizeof(ntrip_t)))) return NULL;
     
     ntrip->state=0;
@@ -1788,6 +2048,7 @@ static ntrip_t *openntrip(const char *path, int type, char *msg)
         free(ntrip);
         return NULL;
     }
+    ntrip->tcp->svr.use_flag=2;
     return ntrip;
 }
 /* close ntrip ---------------------------------------------------------------*/
@@ -1911,7 +2172,7 @@ static void discon_ntripc(ntripc_t *ntripc, int i)
 {
     tracet(3,"discon_ntripc: i=%d\n",i);
     
-    discontcp(&ntripc->tcp->cli[i],ticonnect);
+    discontcp(&ntripc->tcp->cli[i],ticonnect,"");
     ntripc->con[i].nb=0;
     ntripc->con[i].buff[0]='\0';
     ntripc->con[i].state=0;
@@ -1998,7 +2259,7 @@ static void rsp_ntripc(ntripc_t *ntripc, int i)
     con->state=1;
     strcpy(con->mntpnt,mntpnt);
 }
-/* handle ntrip client connect request ---------------------------------------*/
+/* handle ntrip caster client connect request --------------------------------*/
 static void wait_ntripc(ntripc_t *ntripc, char *msg)
 {
     uint8_t *buff;
@@ -2022,7 +2283,13 @@ static void wait_ntripc(ntripc_t *ntripc, char *msg)
                 tracet(2,"wait_ntripc: recv error sock=%d err=%d\n",
                        ntripc->tcp->cli[i].sock,err);
             }
-            discon_ntripc(ntripc,i);
+            if ((err!=EALREADY) && (err!=EINPROGRESS)) {
+               if (err==0)
+                   sprintf(msg,"ntrip caster handshake recv disconnected by %s",ntripc->tcp->cli[i].saddr);
+               else
+                   sprintf(msg,"ntrip caster handshake recv error %d (%s) at %s",err,errorstring(err),ntripc->tcp->cli[i].saddr);
+               discon_ntripc(ntripc,i);
+            }
             continue;
         }
         if (n<=0) continue;
@@ -2051,7 +2318,14 @@ static int readntripc(ntripc_t *ntripc, uint8_t *buff, int n, char *msg)
                 tracet(2,"readntripc: recv error i=%d sock=%d err=%d\n",i,
                        ntripc->tcp->cli[i].sock,err);
             }
-            discon_ntripc(ntripc,i);
+            tracet(2,"readntripc: recv error i=%d sock=%d err=%d\n",i,ntripc->tcp->cli[i].sock,err);
+            if (err!=EALREADY) {
+               if (err==0)
+                   sprintf(msg,"ntrip caster recv disconnected by %s",ntripc->tcp->cli[i].saddr);
+               else
+                   sprintf(msg,"ntrip caster recv error %d (%s) at %s",err,errorstring(err),ntripc->tcp->cli[i].saddr);
+               discon_ntripc(ntripc,i);
+            }
         }
         else if (nr>0) {
             ntripc->tcp->cli[i].tact=tickget();
@@ -2078,7 +2352,12 @@ static int writentripc(ntripc_t *ntripc, uint8_t *buff, int n, char *msg)
             if (err) {
                 tracet(2,"writentripc: send error i=%d sock=%d err=%d\n",i,
                        ntripc->tcp->cli[i].sock,err);
-            }
+                if ((err==EPIPE) && !recv(ntripc->tcp->cli[i].sock,(char *)buff,1,0))
+                   sprintf(msg,"ntrip caster send disconnected by %s",ntripc->tcp->cli[i].saddr);
+                else
+                    sprintf(msg,"ntrip caster send error %d (%s) at %s",err,errorstring(err),ntripc->tcp->cli[i].saddr);
+            } else
+                sprintf(msg,"ntrip caster send not all, disconnected by %s",ntripc->tcp->cli[i].saddr);
             discon_ntripc(ntripc,i);
         }
         else {
@@ -2122,7 +2401,7 @@ static udp_t *genudp(int type, int port, const char *saddr, char *msg)
 {
     udp_t *udp;
     struct hostent *hp;
-    int bs=buffsize,opt=1;
+    int bs=buffsize,opt=1,err;
     
     tracet(3,"genudp: type=%d\n",type);
     
@@ -2134,13 +2413,14 @@ static udp_t *genudp(int type, int port, const char *saddr, char *msg)
     
     if ((udp->sock=socket(AF_INET,SOCK_DGRAM,0))==(socket_t)-1) {
         free(udp);
-        sprintf(msg,"socket error (%d)",errsock());
+        err=errsock();
+        sprintf(msg,"udp socket error %d (%s)",err,errorstring(err));
         return NULL;
     }
     if (setsockopt(udp->sock,SOL_SOCKET,SO_RCVBUF,(const char *)&bs,sizeof(bs))==-1||
         setsockopt(udp->sock,SOL_SOCKET,SO_SNDBUF,(const char *)&bs,sizeof(bs))==-1) {
         tracet(2,"genudp: setsockopt error sock=%d err=%d bs=%d\n",udp->sock,errsock(),bs);
-        sprintf(msg,"sockopt error: bufsiz");
+        sprintf(msg,"udp sockopt error: bufsiz");
     }
     memset(&udp->addr,0,sizeof(udp->addr));
     udp->addr.sin_family=AF_INET;
@@ -2152,8 +2432,9 @@ static udp_t *genudp(int type, int port, const char *saddr, char *msg)
         setsockopt(udp->sock,SOL_SOCKET,SO_REUSEADDR,(const char *)&opt, sizeof(opt));
 #endif
         if (bind(udp->sock,(struct sockaddr *)&udp->addr,sizeof(udp->addr))==-1) {
-            tracet(2,"genudp: bind error sock=%d port=%d err=%d\n",udp->sock,port,errsock());
-            sprintf(msg,"bind error (%d): %d",errsock(),port);
+            err=errsock();
+            tracet(2,"genudp: bind error sock=%d port=%d err=%d\n",udp->sock,port,err);
+            sprintf(msg,"udp bind error %d (%s) at %d",err,errorstring(err),port);
             closesocket(udp->sock);
             free(udp);
             return NULL;
@@ -2164,10 +2445,10 @@ static udp_t *genudp(int type, int port, const char *saddr, char *msg)
             setsockopt(udp->sock,SOL_SOCKET,SO_BROADCAST,(const char *)&opt,
                        sizeof(opt))==-1) {
             tracet(2,"genudp: setsockopt error sock=%d err=%d\n",udp->sock,errsock());
-            sprintf(msg,"sockopt error: broadcast");
+            sprintf(msg,"udp sockopt error: broadcast");
         }
         if (!(hp=gethostbyname(saddr))) {
-            sprintf(msg,"address error (%s)",saddr);
+            sprintf(msg,"udp address error (%s)",saddr);
             closesocket(udp->sock);
             free(udp);
             return NULL;
@@ -2187,7 +2468,7 @@ static udp_t *openudpsvr(const char *path, char *msg)
     decodetcppath(path,NULL,sport,NULL,NULL,NULL,NULL);
     
     if (sscanf(sport,"%d",&port)<1) {
-        sprintf(msg,"port error: %s",sport);
+        sprintf(msg,"udp server port error: %s",sport);
         tracet(2,"openudpsvr: port error port=%s\n",sport);
         return NULL;
     }
@@ -2246,7 +2527,7 @@ static udp_t *openudpcli(const char *path, char *msg)
     decodetcppath(path,saddr,sport,NULL,NULL,NULL,NULL);
     
     if (sscanf(sport,"%d",&port)<1) {
-        sprintf(msg,"port error: %s",sport);
+        sprintf(msg,"udp client port error: %s",sport);
         tracet(2,"openudpcli: port error port=%s\n",sport);
         return NULL;
     }
@@ -2496,7 +2777,7 @@ static int readftp(ftp_t *ftp, uint8_t *buff, int n, char *msg)
     }
     if (ftp->state<=0) { /* ftp/http not executed? */
         ftp->state=1;
-        sprintf(msg,"%s://%s",ftp->proto?"http":"ftp",ftp->addr);
+        sprintf(msg,"open %s://%s",ftp->proto?"http":"ftp",ftp->addr);
     
 #ifdef WIN32
         if (!(ftp->thread=CreateThread(NULL,0,ftpthread,ftp,0,NULL))) {
@@ -2529,7 +2810,7 @@ static int readftp(ftp_t *ftp, uint8_t *buff, int n, char *msg)
     ftp->tnext=nextdltime(ftp->topts,1);
     ftp->state=0;
     
-    strcpy(msg,"");
+    /*strcpy(msg,"");*/
     
     return (int)(p-buff);
 }
@@ -2787,7 +3068,13 @@ extern void strinit(stream_t *stream)
 extern int stropen(stream_t *stream, int type, int mode, const char *path)
 {
     tracet(3,"stropen: type=%d mode=%d path=%s\n",type,mode,path);
-    
+
+    static int first = 1;
+    if (first) {
+       flagcreate("Starting...");
+       first = 0;
+    }
+
     stream->type=type;
     stream->mode=mode;
     strcpy(stream->path,path);
@@ -2851,7 +3138,7 @@ extern void strclose(stream_t *stream)
     stream->path[0]='\0';
     stream->msg[0]='\0';
     stream->port=NULL;
-    
+    flagerase();
     strunlock(stream);
 }
 /* sync streams ----------------------------------------------------------------
@@ -2991,7 +3278,11 @@ extern int strstat(stream_t *stream, char *msg)
     
     strlock(stream);
     if (msg) {
-        strncpy(msg,stream->msg,MAXSTRMSG-1); msg[MAXSTRMSG-1]='\0';
+        if (*stream->msg) {
+           strncpy(msg,stream->msg,MAXSTRMSG-1); msg[MAXSTRMSG-1]='\0';
+           *stream->msg = 0;
+        } else
+           *msg = 0;
     }
     if (!stream->port) {
         strunlock(stream);
